
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `StudentCourse` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model StudentCourse
 * 
 */
export type StudentCourseModel = runtime.Types.Result.DefaultSelection<Prisma.$StudentCoursePayload>

export type AggregateStudentCourse = {
  _count: StudentCourseCountAggregateOutputType | null
  _min: StudentCourseMinAggregateOutputType | null
  _max: StudentCourseMaxAggregateOutputType | null
}

export type StudentCourseMinAggregateOutputType = {
  studentId: string | null
  studentRole: $Enums.Role | null
  courseId: string | null
  assignedAt: Date | null
}

export type StudentCourseMaxAggregateOutputType = {
  studentId: string | null
  studentRole: $Enums.Role | null
  courseId: string | null
  assignedAt: Date | null
}

export type StudentCourseCountAggregateOutputType = {
  studentId: number
  studentRole: number
  courseId: number
  assignedAt: number
  _all: number
}


export type StudentCourseMinAggregateInputType = {
  studentId?: true
  studentRole?: true
  courseId?: true
  assignedAt?: true
}

export type StudentCourseMaxAggregateInputType = {
  studentId?: true
  studentRole?: true
  courseId?: true
  assignedAt?: true
}

export type StudentCourseCountAggregateInputType = {
  studentId?: true
  studentRole?: true
  courseId?: true
  assignedAt?: true
  _all?: true
}

export type StudentCourseAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which StudentCourse to aggregate.
   */
  where?: Prisma.StudentCourseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StudentCourses to fetch.
   */
  orderBy?: Prisma.StudentCourseOrderByWithRelationInput | Prisma.StudentCourseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.StudentCourseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StudentCourses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StudentCourses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned StudentCourses
  **/
  _count?: true | StudentCourseCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: StudentCourseMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: StudentCourseMaxAggregateInputType
}

export type GetStudentCourseAggregateType<T extends StudentCourseAggregateArgs> = {
      [P in keyof T & keyof AggregateStudentCourse]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateStudentCourse[P]>
    : Prisma.GetScalarType<T[P], AggregateStudentCourse[P]>
}




export type StudentCourseGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.StudentCourseWhereInput
  orderBy?: Prisma.StudentCourseOrderByWithAggregationInput | Prisma.StudentCourseOrderByWithAggregationInput[]
  by: Prisma.StudentCourseScalarFieldEnum[] | Prisma.StudentCourseScalarFieldEnum
  having?: Prisma.StudentCourseScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: StudentCourseCountAggregateInputType | true
  _min?: StudentCourseMinAggregateInputType
  _max?: StudentCourseMaxAggregateInputType
}

export type StudentCourseGroupByOutputType = {
  studentId: string
  studentRole: $Enums.Role
  courseId: string
  assignedAt: Date
  _count: StudentCourseCountAggregateOutputType | null
  _min: StudentCourseMinAggregateOutputType | null
  _max: StudentCourseMaxAggregateOutputType | null
}

type GetStudentCourseGroupByPayload<T extends StudentCourseGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<StudentCourseGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof StudentCourseGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], StudentCourseGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], StudentCourseGroupByOutputType[P]>
      }
    >
  >



export type StudentCourseWhereInput = {
  AND?: Prisma.StudentCourseWhereInput | Prisma.StudentCourseWhereInput[]
  OR?: Prisma.StudentCourseWhereInput[]
  NOT?: Prisma.StudentCourseWhereInput | Prisma.StudentCourseWhereInput[]
  studentId?: Prisma.StringFilter<"StudentCourse"> | string
  studentRole?: Prisma.EnumRoleFilter<"StudentCourse"> | $Enums.Role
  courseId?: Prisma.StringFilter<"StudentCourse"> | string
  assignedAt?: Prisma.DateTimeFilter<"StudentCourse"> | Date | string
  student?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  course?: Prisma.XOR<Prisma.CourseScalarRelationFilter, Prisma.CourseWhereInput>
}

export type StudentCourseOrderByWithRelationInput = {
  studentId?: Prisma.SortOrder
  studentRole?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
  student?: Prisma.UserOrderByWithRelationInput
  course?: Prisma.CourseOrderByWithRelationInput
}

export type StudentCourseWhereUniqueInput = Prisma.AtLeast<{
  studentId_courseId?: Prisma.StudentCourseStudentIdCourseIdCompoundUniqueInput
  AND?: Prisma.StudentCourseWhereInput | Prisma.StudentCourseWhereInput[]
  OR?: Prisma.StudentCourseWhereInput[]
  NOT?: Prisma.StudentCourseWhereInput | Prisma.StudentCourseWhereInput[]
  studentId?: Prisma.StringFilter<"StudentCourse"> | string
  studentRole?: Prisma.EnumRoleFilter<"StudentCourse"> | $Enums.Role
  courseId?: Prisma.StringFilter<"StudentCourse"> | string
  assignedAt?: Prisma.DateTimeFilter<"StudentCourse"> | Date | string
  student?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  course?: Prisma.XOR<Prisma.CourseScalarRelationFilter, Prisma.CourseWhereInput>
}, "studentId_courseId">

export type StudentCourseOrderByWithAggregationInput = {
  studentId?: Prisma.SortOrder
  studentRole?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
  _count?: Prisma.StudentCourseCountOrderByAggregateInput
  _max?: Prisma.StudentCourseMaxOrderByAggregateInput
  _min?: Prisma.StudentCourseMinOrderByAggregateInput
}

export type StudentCourseScalarWhereWithAggregatesInput = {
  AND?: Prisma.StudentCourseScalarWhereWithAggregatesInput | Prisma.StudentCourseScalarWhereWithAggregatesInput[]
  OR?: Prisma.StudentCourseScalarWhereWithAggregatesInput[]
  NOT?: Prisma.StudentCourseScalarWhereWithAggregatesInput | Prisma.StudentCourseScalarWhereWithAggregatesInput[]
  studentId?: Prisma.StringWithAggregatesFilter<"StudentCourse"> | string
  studentRole?: Prisma.EnumRoleWithAggregatesFilter<"StudentCourse"> | $Enums.Role
  courseId?: Prisma.StringWithAggregatesFilter<"StudentCourse"> | string
  assignedAt?: Prisma.DateTimeWithAggregatesFilter<"StudentCourse"> | Date | string
}

export type StudentCourseCreateInput = {
  assignedAt?: Date | string
  student: Prisma.UserCreateNestedOneWithoutCoursesStudiedInput
  course: Prisma.CourseCreateNestedOneWithoutStudentsInput
}

export type StudentCourseUncheckedCreateInput = {
  studentId: string
  studentRole?: $Enums.Role
  courseId: string
  assignedAt?: Date | string
}

export type StudentCourseUpdateInput = {
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  student?: Prisma.UserUpdateOneRequiredWithoutCoursesStudiedNestedInput
  course?: Prisma.CourseUpdateOneRequiredWithoutStudentsNestedInput
}

export type StudentCourseUncheckedUpdateInput = {
  studentId?: Prisma.StringFieldUpdateOperationsInput | string
  studentRole?: Prisma.EnumRoleFieldUpdateOperationsInput | $Enums.Role
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StudentCourseCreateManyInput = {
  studentId: string
  studentRole?: $Enums.Role
  courseId: string
  assignedAt?: Date | string
}

export type StudentCourseUpdateManyMutationInput = {
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StudentCourseUncheckedUpdateManyInput = {
  studentId?: Prisma.StringFieldUpdateOperationsInput | string
  studentRole?: Prisma.EnumRoleFieldUpdateOperationsInput | $Enums.Role
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StudentCourseListRelationFilter = {
  every?: Prisma.StudentCourseWhereInput
  some?: Prisma.StudentCourseWhereInput
  none?: Prisma.StudentCourseWhereInput
}

export type StudentCourseOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type StudentCourseStudentIdCourseIdCompoundUniqueInput = {
  studentId: string
  courseId: string
}

export type StudentCourseCountOrderByAggregateInput = {
  studentId?: Prisma.SortOrder
  studentRole?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
}

export type StudentCourseMaxOrderByAggregateInput = {
  studentId?: Prisma.SortOrder
  studentRole?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
}

export type StudentCourseMinOrderByAggregateInput = {
  studentId?: Prisma.SortOrder
  studentRole?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
}

export type StudentCourseCreateNestedManyWithoutStudentInput = {
  create?: Prisma.XOR<Prisma.StudentCourseCreateWithoutStudentInput, Prisma.StudentCourseUncheckedCreateWithoutStudentInput> | Prisma.StudentCourseCreateWithoutStudentInput[] | Prisma.StudentCourseUncheckedCreateWithoutStudentInput[]
  connectOrCreate?: Prisma.StudentCourseCreateOrConnectWithoutStudentInput | Prisma.StudentCourseCreateOrConnectWithoutStudentInput[]
  createMany?: Prisma.StudentCourseCreateManyStudentInputEnvelope
  connect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
}

export type StudentCourseUncheckedCreateNestedManyWithoutStudentInput = {
  create?: Prisma.XOR<Prisma.StudentCourseCreateWithoutStudentInput, Prisma.StudentCourseUncheckedCreateWithoutStudentInput> | Prisma.StudentCourseCreateWithoutStudentInput[] | Prisma.StudentCourseUncheckedCreateWithoutStudentInput[]
  connectOrCreate?: Prisma.StudentCourseCreateOrConnectWithoutStudentInput | Prisma.StudentCourseCreateOrConnectWithoutStudentInput[]
  createMany?: Prisma.StudentCourseCreateManyStudentInputEnvelope
  connect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
}

export type StudentCourseUpdateManyWithoutStudentNestedInput = {
  create?: Prisma.XOR<Prisma.StudentCourseCreateWithoutStudentInput, Prisma.StudentCourseUncheckedCreateWithoutStudentInput> | Prisma.StudentCourseCreateWithoutStudentInput[] | Prisma.StudentCourseUncheckedCreateWithoutStudentInput[]
  connectOrCreate?: Prisma.StudentCourseCreateOrConnectWithoutStudentInput | Prisma.StudentCourseCreateOrConnectWithoutStudentInput[]
  upsert?: Prisma.StudentCourseUpsertWithWhereUniqueWithoutStudentInput | Prisma.StudentCourseUpsertWithWhereUniqueWithoutStudentInput[]
  createMany?: Prisma.StudentCourseCreateManyStudentInputEnvelope
  set?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  disconnect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  delete?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  connect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  update?: Prisma.StudentCourseUpdateWithWhereUniqueWithoutStudentInput | Prisma.StudentCourseUpdateWithWhereUniqueWithoutStudentInput[]
  updateMany?: Prisma.StudentCourseUpdateManyWithWhereWithoutStudentInput | Prisma.StudentCourseUpdateManyWithWhereWithoutStudentInput[]
  deleteMany?: Prisma.StudentCourseScalarWhereInput | Prisma.StudentCourseScalarWhereInput[]
}

export type StudentCourseUncheckedUpdateManyWithoutStudentNestedInput = {
  create?: Prisma.XOR<Prisma.StudentCourseCreateWithoutStudentInput, Prisma.StudentCourseUncheckedCreateWithoutStudentInput> | Prisma.StudentCourseCreateWithoutStudentInput[] | Prisma.StudentCourseUncheckedCreateWithoutStudentInput[]
  connectOrCreate?: Prisma.StudentCourseCreateOrConnectWithoutStudentInput | Prisma.StudentCourseCreateOrConnectWithoutStudentInput[]
  upsert?: Prisma.StudentCourseUpsertWithWhereUniqueWithoutStudentInput | Prisma.StudentCourseUpsertWithWhereUniqueWithoutStudentInput[]
  createMany?: Prisma.StudentCourseCreateManyStudentInputEnvelope
  set?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  disconnect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  delete?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  connect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  update?: Prisma.StudentCourseUpdateWithWhereUniqueWithoutStudentInput | Prisma.StudentCourseUpdateWithWhereUniqueWithoutStudentInput[]
  updateMany?: Prisma.StudentCourseUpdateManyWithWhereWithoutStudentInput | Prisma.StudentCourseUpdateManyWithWhereWithoutStudentInput[]
  deleteMany?: Prisma.StudentCourseScalarWhereInput | Prisma.StudentCourseScalarWhereInput[]
}

export type StudentCourseCreateNestedManyWithoutCourseInput = {
  create?: Prisma.XOR<Prisma.StudentCourseCreateWithoutCourseInput, Prisma.StudentCourseUncheckedCreateWithoutCourseInput> | Prisma.StudentCourseCreateWithoutCourseInput[] | Prisma.StudentCourseUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.StudentCourseCreateOrConnectWithoutCourseInput | Prisma.StudentCourseCreateOrConnectWithoutCourseInput[]
  createMany?: Prisma.StudentCourseCreateManyCourseInputEnvelope
  connect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
}

export type StudentCourseUncheckedCreateNestedManyWithoutCourseInput = {
  create?: Prisma.XOR<Prisma.StudentCourseCreateWithoutCourseInput, Prisma.StudentCourseUncheckedCreateWithoutCourseInput> | Prisma.StudentCourseCreateWithoutCourseInput[] | Prisma.StudentCourseUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.StudentCourseCreateOrConnectWithoutCourseInput | Prisma.StudentCourseCreateOrConnectWithoutCourseInput[]
  createMany?: Prisma.StudentCourseCreateManyCourseInputEnvelope
  connect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
}

export type StudentCourseUpdateManyWithoutCourseNestedInput = {
  create?: Prisma.XOR<Prisma.StudentCourseCreateWithoutCourseInput, Prisma.StudentCourseUncheckedCreateWithoutCourseInput> | Prisma.StudentCourseCreateWithoutCourseInput[] | Prisma.StudentCourseUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.StudentCourseCreateOrConnectWithoutCourseInput | Prisma.StudentCourseCreateOrConnectWithoutCourseInput[]
  upsert?: Prisma.StudentCourseUpsertWithWhereUniqueWithoutCourseInput | Prisma.StudentCourseUpsertWithWhereUniqueWithoutCourseInput[]
  createMany?: Prisma.StudentCourseCreateManyCourseInputEnvelope
  set?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  disconnect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  delete?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  connect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  update?: Prisma.StudentCourseUpdateWithWhereUniqueWithoutCourseInput | Prisma.StudentCourseUpdateWithWhereUniqueWithoutCourseInput[]
  updateMany?: Prisma.StudentCourseUpdateManyWithWhereWithoutCourseInput | Prisma.StudentCourseUpdateManyWithWhereWithoutCourseInput[]
  deleteMany?: Prisma.StudentCourseScalarWhereInput | Prisma.StudentCourseScalarWhereInput[]
}

export type StudentCourseUncheckedUpdateManyWithoutCourseNestedInput = {
  create?: Prisma.XOR<Prisma.StudentCourseCreateWithoutCourseInput, Prisma.StudentCourseUncheckedCreateWithoutCourseInput> | Prisma.StudentCourseCreateWithoutCourseInput[] | Prisma.StudentCourseUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.StudentCourseCreateOrConnectWithoutCourseInput | Prisma.StudentCourseCreateOrConnectWithoutCourseInput[]
  upsert?: Prisma.StudentCourseUpsertWithWhereUniqueWithoutCourseInput | Prisma.StudentCourseUpsertWithWhereUniqueWithoutCourseInput[]
  createMany?: Prisma.StudentCourseCreateManyCourseInputEnvelope
  set?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  disconnect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  delete?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  connect?: Prisma.StudentCourseWhereUniqueInput | Prisma.StudentCourseWhereUniqueInput[]
  update?: Prisma.StudentCourseUpdateWithWhereUniqueWithoutCourseInput | Prisma.StudentCourseUpdateWithWhereUniqueWithoutCourseInput[]
  updateMany?: Prisma.StudentCourseUpdateManyWithWhereWithoutCourseInput | Prisma.StudentCourseUpdateManyWithWhereWithoutCourseInput[]
  deleteMany?: Prisma.StudentCourseScalarWhereInput | Prisma.StudentCourseScalarWhereInput[]
}

export type DateTimeFieldUpdateOperationsInput = {
  set?: Date | string
}

export type StudentCourseCreateWithoutStudentInput = {
  assignedAt?: Date | string
  course: Prisma.CourseCreateNestedOneWithoutStudentsInput
}

export type StudentCourseUncheckedCreateWithoutStudentInput = {
  courseId: string
  assignedAt?: Date | string
}

export type StudentCourseCreateOrConnectWithoutStudentInput = {
  where: Prisma.StudentCourseWhereUniqueInput
  create: Prisma.XOR<Prisma.StudentCourseCreateWithoutStudentInput, Prisma.StudentCourseUncheckedCreateWithoutStudentInput>
}

export type StudentCourseCreateManyStudentInputEnvelope = {
  data: Prisma.StudentCourseCreateManyStudentInput | Prisma.StudentCourseCreateManyStudentInput[]
  skipDuplicates?: boolean
}

export type StudentCourseUpsertWithWhereUniqueWithoutStudentInput = {
  where: Prisma.StudentCourseWhereUniqueInput
  update: Prisma.XOR<Prisma.StudentCourseUpdateWithoutStudentInput, Prisma.StudentCourseUncheckedUpdateWithoutStudentInput>
  create: Prisma.XOR<Prisma.StudentCourseCreateWithoutStudentInput, Prisma.StudentCourseUncheckedCreateWithoutStudentInput>
}

export type StudentCourseUpdateWithWhereUniqueWithoutStudentInput = {
  where: Prisma.StudentCourseWhereUniqueInput
  data: Prisma.XOR<Prisma.StudentCourseUpdateWithoutStudentInput, Prisma.StudentCourseUncheckedUpdateWithoutStudentInput>
}

export type StudentCourseUpdateManyWithWhereWithoutStudentInput = {
  where: Prisma.StudentCourseScalarWhereInput
  data: Prisma.XOR<Prisma.StudentCourseUpdateManyMutationInput, Prisma.StudentCourseUncheckedUpdateManyWithoutStudentInput>
}

export type StudentCourseScalarWhereInput = {
  AND?: Prisma.StudentCourseScalarWhereInput | Prisma.StudentCourseScalarWhereInput[]
  OR?: Prisma.StudentCourseScalarWhereInput[]
  NOT?: Prisma.StudentCourseScalarWhereInput | Prisma.StudentCourseScalarWhereInput[]
  studentId?: Prisma.StringFilter<"StudentCourse"> | string
  studentRole?: Prisma.EnumRoleFilter<"StudentCourse"> | $Enums.Role
  courseId?: Prisma.StringFilter<"StudentCourse"> | string
  assignedAt?: Prisma.DateTimeFilter<"StudentCourse"> | Date | string
}

export type StudentCourseCreateWithoutCourseInput = {
  assignedAt?: Date | string
  student: Prisma.UserCreateNestedOneWithoutCoursesStudiedInput
}

export type StudentCourseUncheckedCreateWithoutCourseInput = {
  studentId: string
  studentRole?: $Enums.Role
  assignedAt?: Date | string
}

export type StudentCourseCreateOrConnectWithoutCourseInput = {
  where: Prisma.StudentCourseWhereUniqueInput
  create: Prisma.XOR<Prisma.StudentCourseCreateWithoutCourseInput, Prisma.StudentCourseUncheckedCreateWithoutCourseInput>
}

export type StudentCourseCreateManyCourseInputEnvelope = {
  data: Prisma.StudentCourseCreateManyCourseInput | Prisma.StudentCourseCreateManyCourseInput[]
  skipDuplicates?: boolean
}

export type StudentCourseUpsertWithWhereUniqueWithoutCourseInput = {
  where: Prisma.StudentCourseWhereUniqueInput
  update: Prisma.XOR<Prisma.StudentCourseUpdateWithoutCourseInput, Prisma.StudentCourseUncheckedUpdateWithoutCourseInput>
  create: Prisma.XOR<Prisma.StudentCourseCreateWithoutCourseInput, Prisma.StudentCourseUncheckedCreateWithoutCourseInput>
}

export type StudentCourseUpdateWithWhereUniqueWithoutCourseInput = {
  where: Prisma.StudentCourseWhereUniqueInput
  data: Prisma.XOR<Prisma.StudentCourseUpdateWithoutCourseInput, Prisma.StudentCourseUncheckedUpdateWithoutCourseInput>
}

export type StudentCourseUpdateManyWithWhereWithoutCourseInput = {
  where: Prisma.StudentCourseScalarWhereInput
  data: Prisma.XOR<Prisma.StudentCourseUpdateManyMutationInput, Prisma.StudentCourseUncheckedUpdateManyWithoutCourseInput>
}

export type StudentCourseCreateManyStudentInput = {
  courseId: string
  assignedAt?: Date | string
}

export type StudentCourseUpdateWithoutStudentInput = {
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  course?: Prisma.CourseUpdateOneRequiredWithoutStudentsNestedInput
}

export type StudentCourseUncheckedUpdateWithoutStudentInput = {
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StudentCourseUncheckedUpdateManyWithoutStudentInput = {
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StudentCourseCreateManyCourseInput = {
  studentId: string
  studentRole?: $Enums.Role
  assignedAt?: Date | string
}

export type StudentCourseUpdateWithoutCourseInput = {
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  student?: Prisma.UserUpdateOneRequiredWithoutCoursesStudiedNestedInput
}

export type StudentCourseUncheckedUpdateWithoutCourseInput = {
  studentId?: Prisma.StringFieldUpdateOperationsInput | string
  studentRole?: Prisma.EnumRoleFieldUpdateOperationsInput | $Enums.Role
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StudentCourseUncheckedUpdateManyWithoutCourseInput = {
  studentId?: Prisma.StringFieldUpdateOperationsInput | string
  studentRole?: Prisma.EnumRoleFieldUpdateOperationsInput | $Enums.Role
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type StudentCourseSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  studentId?: boolean
  studentRole?: boolean
  courseId?: boolean
  assignedAt?: boolean
  student?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}, ExtArgs["result"]["studentCourse"]>

export type StudentCourseSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  studentId?: boolean
  studentRole?: boolean
  courseId?: boolean
  assignedAt?: boolean
  student?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}, ExtArgs["result"]["studentCourse"]>

export type StudentCourseSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  studentId?: boolean
  studentRole?: boolean
  courseId?: boolean
  assignedAt?: boolean
  student?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}, ExtArgs["result"]["studentCourse"]>

export type StudentCourseSelectScalar = {
  studentId?: boolean
  studentRole?: boolean
  courseId?: boolean
  assignedAt?: boolean
}

export type StudentCourseOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"studentId" | "studentRole" | "courseId" | "assignedAt", ExtArgs["result"]["studentCourse"]>
export type StudentCourseInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  student?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}
export type StudentCourseIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  student?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}
export type StudentCourseIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  student?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}

export type $StudentCoursePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "StudentCourse"
  objects: {
    student: Prisma.$UserPayload<ExtArgs>
    course: Prisma.$CoursePayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    studentId: string
    studentRole: $Enums.Role
    courseId: string
    assignedAt: Date
  }, ExtArgs["result"]["studentCourse"]>
  composites: {}
}

export type StudentCourseGetPayload<S extends boolean | null | undefined | StudentCourseDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload, S>

export type StudentCourseCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<StudentCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: StudentCourseCountAggregateInputType | true
  }

export interface StudentCourseDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentCourse'], meta: { name: 'StudentCourse' } }
  /**
   * Find zero or one StudentCourse that matches the filter.
   * @param {StudentCourseFindUniqueArgs} args - Arguments to find a StudentCourse
   * @example
   * // Get one StudentCourse
   * const studentCourse = await prisma.studentCourse.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends StudentCourseFindUniqueArgs>(args: Prisma.SelectSubset<T, StudentCourseFindUniqueArgs<ExtArgs>>): Prisma.Prisma__StudentCourseClient<runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one StudentCourse that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {StudentCourseFindUniqueOrThrowArgs} args - Arguments to find a StudentCourse
   * @example
   * // Get one StudentCourse
   * const studentCourse = await prisma.studentCourse.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends StudentCourseFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, StudentCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__StudentCourseClient<runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first StudentCourse that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StudentCourseFindFirstArgs} args - Arguments to find a StudentCourse
   * @example
   * // Get one StudentCourse
   * const studentCourse = await prisma.studentCourse.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends StudentCourseFindFirstArgs>(args?: Prisma.SelectSubset<T, StudentCourseFindFirstArgs<ExtArgs>>): Prisma.Prisma__StudentCourseClient<runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first StudentCourse that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StudentCourseFindFirstOrThrowArgs} args - Arguments to find a StudentCourse
   * @example
   * // Get one StudentCourse
   * const studentCourse = await prisma.studentCourse.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends StudentCourseFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, StudentCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__StudentCourseClient<runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more StudentCourses that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StudentCourseFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all StudentCourses
   * const studentCourses = await prisma.studentCourse.findMany()
   * 
   * // Get first 10 StudentCourses
   * const studentCourses = await prisma.studentCourse.findMany({ take: 10 })
   * 
   * // Only select the `studentId`
   * const studentCourseWithStudentIdOnly = await prisma.studentCourse.findMany({ select: { studentId: true } })
   * 
   */
  findMany<T extends StudentCourseFindManyArgs>(args?: Prisma.SelectSubset<T, StudentCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a StudentCourse.
   * @param {StudentCourseCreateArgs} args - Arguments to create a StudentCourse.
   * @example
   * // Create one StudentCourse
   * const StudentCourse = await prisma.studentCourse.create({
   *   data: {
   *     // ... data to create a StudentCourse
   *   }
   * })
   * 
   */
  create<T extends StudentCourseCreateArgs>(args: Prisma.SelectSubset<T, StudentCourseCreateArgs<ExtArgs>>): Prisma.Prisma__StudentCourseClient<runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many StudentCourses.
   * @param {StudentCourseCreateManyArgs} args - Arguments to create many StudentCourses.
   * @example
   * // Create many StudentCourses
   * const studentCourse = await prisma.studentCourse.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends StudentCourseCreateManyArgs>(args?: Prisma.SelectSubset<T, StudentCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many StudentCourses and returns the data saved in the database.
   * @param {StudentCourseCreateManyAndReturnArgs} args - Arguments to create many StudentCourses.
   * @example
   * // Create many StudentCourses
   * const studentCourse = await prisma.studentCourse.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many StudentCourses and only return the `studentId`
   * const studentCourseWithStudentIdOnly = await prisma.studentCourse.createManyAndReturn({
   *   select: { studentId: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends StudentCourseCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, StudentCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a StudentCourse.
   * @param {StudentCourseDeleteArgs} args - Arguments to delete one StudentCourse.
   * @example
   * // Delete one StudentCourse
   * const StudentCourse = await prisma.studentCourse.delete({
   *   where: {
   *     // ... filter to delete one StudentCourse
   *   }
   * })
   * 
   */
  delete<T extends StudentCourseDeleteArgs>(args: Prisma.SelectSubset<T, StudentCourseDeleteArgs<ExtArgs>>): Prisma.Prisma__StudentCourseClient<runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one StudentCourse.
   * @param {StudentCourseUpdateArgs} args - Arguments to update one StudentCourse.
   * @example
   * // Update one StudentCourse
   * const studentCourse = await prisma.studentCourse.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends StudentCourseUpdateArgs>(args: Prisma.SelectSubset<T, StudentCourseUpdateArgs<ExtArgs>>): Prisma.Prisma__StudentCourseClient<runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more StudentCourses.
   * @param {StudentCourseDeleteManyArgs} args - Arguments to filter StudentCourses to delete.
   * @example
   * // Delete a few StudentCourses
   * const { count } = await prisma.studentCourse.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends StudentCourseDeleteManyArgs>(args?: Prisma.SelectSubset<T, StudentCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more StudentCourses.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StudentCourseUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many StudentCourses
   * const studentCourse = await prisma.studentCourse.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends StudentCourseUpdateManyArgs>(args: Prisma.SelectSubset<T, StudentCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more StudentCourses and returns the data updated in the database.
   * @param {StudentCourseUpdateManyAndReturnArgs} args - Arguments to update many StudentCourses.
   * @example
   * // Update many StudentCourses
   * const studentCourse = await prisma.studentCourse.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more StudentCourses and only return the `studentId`
   * const studentCourseWithStudentIdOnly = await prisma.studentCourse.updateManyAndReturn({
   *   select: { studentId: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends StudentCourseUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, StudentCourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one StudentCourse.
   * @param {StudentCourseUpsertArgs} args - Arguments to update or create a StudentCourse.
   * @example
   * // Update or create a StudentCourse
   * const studentCourse = await prisma.studentCourse.upsert({
   *   create: {
   *     // ... data to create a StudentCourse
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the StudentCourse we want to update
   *   }
   * })
   */
  upsert<T extends StudentCourseUpsertArgs>(args: Prisma.SelectSubset<T, StudentCourseUpsertArgs<ExtArgs>>): Prisma.Prisma__StudentCourseClient<runtime.Types.Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of StudentCourses.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StudentCourseCountArgs} args - Arguments to filter StudentCourses to count.
   * @example
   * // Count the number of StudentCourses
   * const count = await prisma.studentCourse.count({
   *   where: {
   *     // ... the filter for the StudentCourses we want to count
   *   }
   * })
  **/
  count<T extends StudentCourseCountArgs>(
    args?: Prisma.Subset<T, StudentCourseCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], StudentCourseCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a StudentCourse.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StudentCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends StudentCourseAggregateArgs>(args: Prisma.Subset<T, StudentCourseAggregateArgs>): Prisma.PrismaPromise<GetStudentCourseAggregateType<T>>

  /**
   * Group by StudentCourse.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StudentCourseGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends StudentCourseGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: StudentCourseGroupByArgs['orderBy'] }
      : { orderBy?: StudentCourseGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, StudentCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the StudentCourse model
 */
readonly fields: StudentCourseFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for StudentCourse.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__StudentCourseClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  student<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  course<T extends Prisma.CourseDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.CourseDefaultArgs<ExtArgs>>): Prisma.Prisma__CourseClient<runtime.Types.Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the StudentCourse model
 */
export interface StudentCourseFieldRefs {
  readonly studentId: Prisma.FieldRef<"StudentCourse", 'String'>
  readonly studentRole: Prisma.FieldRef<"StudentCourse", 'Role'>
  readonly courseId: Prisma.FieldRef<"StudentCourse", 'String'>
  readonly assignedAt: Prisma.FieldRef<"StudentCourse", 'DateTime'>
}
    

// Custom InputTypes
/**
 * StudentCourse findUnique
 */
export type StudentCourseFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseInclude<ExtArgs> | null
  /**
   * Filter, which StudentCourse to fetch.
   */
  where: Prisma.StudentCourseWhereUniqueInput
}

/**
 * StudentCourse findUniqueOrThrow
 */
export type StudentCourseFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseInclude<ExtArgs> | null
  /**
   * Filter, which StudentCourse to fetch.
   */
  where: Prisma.StudentCourseWhereUniqueInput
}

/**
 * StudentCourse findFirst
 */
export type StudentCourseFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseInclude<ExtArgs> | null
  /**
   * Filter, which StudentCourse to fetch.
   */
  where?: Prisma.StudentCourseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StudentCourses to fetch.
   */
  orderBy?: Prisma.StudentCourseOrderByWithRelationInput | Prisma.StudentCourseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for StudentCourses.
   */
  cursor?: Prisma.StudentCourseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StudentCourses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StudentCourses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of StudentCourses.
   */
  distinct?: Prisma.StudentCourseScalarFieldEnum | Prisma.StudentCourseScalarFieldEnum[]
}

/**
 * StudentCourse findFirstOrThrow
 */
export type StudentCourseFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseInclude<ExtArgs> | null
  /**
   * Filter, which StudentCourse to fetch.
   */
  where?: Prisma.StudentCourseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StudentCourses to fetch.
   */
  orderBy?: Prisma.StudentCourseOrderByWithRelationInput | Prisma.StudentCourseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for StudentCourses.
   */
  cursor?: Prisma.StudentCourseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StudentCourses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StudentCourses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of StudentCourses.
   */
  distinct?: Prisma.StudentCourseScalarFieldEnum | Prisma.StudentCourseScalarFieldEnum[]
}

/**
 * StudentCourse findMany
 */
export type StudentCourseFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseInclude<ExtArgs> | null
  /**
   * Filter, which StudentCourses to fetch.
   */
  where?: Prisma.StudentCourseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StudentCourses to fetch.
   */
  orderBy?: Prisma.StudentCourseOrderByWithRelationInput | Prisma.StudentCourseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing StudentCourses.
   */
  cursor?: Prisma.StudentCourseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StudentCourses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StudentCourses.
   */
  skip?: number
  distinct?: Prisma.StudentCourseScalarFieldEnum | Prisma.StudentCourseScalarFieldEnum[]
}

/**
 * StudentCourse create
 */
export type StudentCourseCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseInclude<ExtArgs> | null
  /**
   * The data needed to create a StudentCourse.
   */
  data: Prisma.XOR<Prisma.StudentCourseCreateInput, Prisma.StudentCourseUncheckedCreateInput>
}

/**
 * StudentCourse createMany
 */
export type StudentCourseCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many StudentCourses.
   */
  data: Prisma.StudentCourseCreateManyInput | Prisma.StudentCourseCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * StudentCourse createManyAndReturn
 */
export type StudentCourseCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * The data used to create many StudentCourses.
   */
  data: Prisma.StudentCourseCreateManyInput | Prisma.StudentCourseCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * StudentCourse update
 */
export type StudentCourseUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseInclude<ExtArgs> | null
  /**
   * The data needed to update a StudentCourse.
   */
  data: Prisma.XOR<Prisma.StudentCourseUpdateInput, Prisma.StudentCourseUncheckedUpdateInput>
  /**
   * Choose, which StudentCourse to update.
   */
  where: Prisma.StudentCourseWhereUniqueInput
}

/**
 * StudentCourse updateMany
 */
export type StudentCourseUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update StudentCourses.
   */
  data: Prisma.XOR<Prisma.StudentCourseUpdateManyMutationInput, Prisma.StudentCourseUncheckedUpdateManyInput>
  /**
   * Filter which StudentCourses to update
   */
  where?: Prisma.StudentCourseWhereInput
  /**
   * Limit how many StudentCourses to update.
   */
  limit?: number
}

/**
 * StudentCourse updateManyAndReturn
 */
export type StudentCourseUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * The data used to update StudentCourses.
   */
  data: Prisma.XOR<Prisma.StudentCourseUpdateManyMutationInput, Prisma.StudentCourseUncheckedUpdateManyInput>
  /**
   * Filter which StudentCourses to update
   */
  where?: Prisma.StudentCourseWhereInput
  /**
   * Limit how many StudentCourses to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * StudentCourse upsert
 */
export type StudentCourseUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseInclude<ExtArgs> | null
  /**
   * The filter to search for the StudentCourse to update in case it exists.
   */
  where: Prisma.StudentCourseWhereUniqueInput
  /**
   * In case the StudentCourse found by the `where` argument doesn't exist, create a new StudentCourse with this data.
   */
  create: Prisma.XOR<Prisma.StudentCourseCreateInput, Prisma.StudentCourseUncheckedCreateInput>
  /**
   * In case the StudentCourse was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.StudentCourseUpdateInput, Prisma.StudentCourseUncheckedUpdateInput>
}

/**
 * StudentCourse delete
 */
export type StudentCourseDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseInclude<ExtArgs> | null
  /**
   * Filter which StudentCourse to delete.
   */
  where: Prisma.StudentCourseWhereUniqueInput
}

/**
 * StudentCourse deleteMany
 */
export type StudentCourseDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which StudentCourses to delete
   */
  where?: Prisma.StudentCourseWhereInput
  /**
   * Limit how many StudentCourses to delete.
   */
  limit?: number
}

/**
 * StudentCourse without action
 */
export type StudentCourseDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StudentCourse
   */
  select?: Prisma.StudentCourseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StudentCourse
   */
  omit?: Prisma.StudentCourseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StudentCourseInclude<ExtArgs> | null
}
